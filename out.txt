{
"CustomHash.cpp": {
	"prefix": "CustomHash.cpp" ,
	"body": ["#include <ext/pb_ds/assoc_container.hpp>","using int64 = lli;","struct custom_hash {","    static uint64_t splitmix64(uint64_t x) {","        x += 0x9e3779b97f4a7c15;","        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;","        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;","        return x ^ (x >> 31);","    }","","    size_t operator()(uint64_t x) const {","        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();","        return splitmix64(x + FIXED_RANDOM);","    }","};",]
},
"Basic.cpp": {
	"prefix": "Basic.cpp" ,
	"body": ["long long gcd(long long a, long long b){ return b? gcd(b, a%b) : a; }","long long lcm(long long a, long long b){ return (!a or !b)? 0 : a * b / gcd(a,b); }","long long  poww(long long  a, long long b){","	long long res = 1;","	while(b){","		if(b%2) res = res * a ;","		a = a * a;  b>>=1;","	} return res;","}",]
},
"Random.cpp": {
	"prefix": "Random.cpp" ,
	"body": ["mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());","int rnd(int n){return uniform_int_distribution<int>(0, n-1)(rng);}",]
},
"Modulo.cpp": {
	"prefix": "Modulo.cpp" ,
	"body": ["using uint = unsigned;","using ull = unsigned long long;","struct modinfo {uint mod, root; };","template <modinfo const &ref> struct modular {","	 static constexpr uint const &mod = ref.mod;","	 static modular root() { return modular(ref.root); }","	 uint v;","	 // modular(initializer_list<uint>ls):v(*ls.bg){}","	 modular(long long int vv = 0) { s(vv % mod + mod); }","	 modular &s(uint vv) {","			 v = vv < mod ? vv : vv - mod;","			 return *this;","	 }","	 modular operator-() const { return modular() - *this; }","	 modular &operator+=(const modular &rhs) { return s(v + rhs.v); }","	 modular &operator-=(const modular &rhs) { return s(v + mod - rhs.v); }","	 modular &operator*=(const modular &rhs) {","			 v = ull(v) * rhs.v % mod;","			 return *this;","	 }","	 modular &operator/=(const modular &rhs) { return *this *= rhs.inv(); }","	 modular operator+(const modular &rhs) const { return modular(*this) += rhs; }","	 modular operator-(const modular &rhs) const { return modular(*this) -= rhs; }","	 modular operator*(const modular &rhs) const { return modular(*this) *= rhs; }","	 modular operator/(const modular &rhs) const { return modular(*this) /= rhs; }","	 modular pow(int n) const {","			 modular res(1), x(*this);","			 while(n) {","					 if(n & 1) res *= x;","					 x *= x;","					 n >>= 1;","			 }","			 return res;","	 }","	 modular inv() const { return pow(mod - 2); }","	 friend modular operator+(int x, const modular &y) { return modular(x) + y; }","	 friend modular operator-(int x, const modular &y) { return modular(x) - y; }","	 friend modular operator*(int x, const modular &y) { return modular(x) * y; }","	 friend modular operator/(int x, const modular &y) { return modular(x) / y; }","	 friend ostream &operator<<(ostream &os, const modular &m) { return os << m.v; }","	 friend istream &operator>>(istream &is, modular &m) {","			 long long int x;","			 is >> x;","			 m = modular(x);","			 return is;","	 }","	 bool operator<(const modular &r) const { return v < r.v; }","	 bool operator==(const modular &r) const { return v == r.v; }","	 bool operator!=(const modular &r) const { return v != r.v; }","	 explicit operator bool() const { return v; }","};","","// extern constexpr modinfo base{998244353, 3};","extern constexpr modinfo base{1000000007, 0};","// modinfo base{1,0};","using mint = modular<base>;","","","const int vmax=(1<<21)+10;","mint fact[vmax],finv[vmax],invs[vmax];","void initfact(){","	fact[0]=1;","	fore(i,1,vmax)fact[i]=fact[i-1]*i;","	finv[vmax-1]=fact[vmax-1].inv();","	for(int i=vmax-2;i>=0;i--)finv[i]=finv[i+1]*(i+1);","	for(int i=vmax-1;i>=1;i--)invs[i]=finv[i]*fact[i-1];","}","mint choose(int n,int k){","	return fact[n]*finv[n-k]*finv[k];","}","mint binom(int a,int b){","	return fact[a+b]*finv[a]*finv[b];","}","mint catalan(int n){","	return binom(n,n)-(n-1>=0?binom(n-1,n+1):0);","}",]
},
"FastM.cpp": {
	"prefix": "FastM.cpp" ,
	"body": ["const int mod = 1e9+7;","","li Sum(li a, li b){","	a = (a%mod + mod)%mod;","	b = (b%mod + mod)%mod;","    return (a+b)%mod;","}","","li Mul(li a, li b){","	a = (a%mod + mod)%mod;","	b = (b%mod + mod)%mod;","    return (a*b)%mod;","}","","li Pow(long long  a, long long b){","	int res = 1;","	while(b){","		if(b%2) res = Mul(res,a);","		a = Mul(a,a);  b>>=1;","	} return res;","}","","li Inv(li a){","    return Pow(a,mod-2);","}","",]
},
"OrderedSet.cpp": {
	"prefix": "OrderedSet.cpp" ,
	"body": ["#include <ext/pb_ds/assoc_container.hpp>","#include <ext/pb_ds/trie_policy.hpp>","using namespace __gnu_pbds;","typedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;",]
},
"CompetitiveTemplate.cpp": {
	"prefix": "CompetitiveTemplate.cpp" ,
	"body": ["#include <bits/stdc++.h>","#define f first","#define s second","#define fore(i,a,b) for(int i = (a), ThxMK = (b); i < ThxMK; ++i)","#define pb push_back","#define all(s) begin(s), end(s)","#define _ ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);","#define sz(s) int(s.size())","#define ENDL '\n'","#define vv(type, name, h, ...) vector<vector<type>> name(h, vector<type>(__VA_ARGS__))","#define vvv(type, name, h, w, ...) vector<vector<vector<type>>> name(h, vector<vector<type>>(w, vector<type>(__VA_ARGS__)))","using namespace std;","","template <typename T> static constexpr T inf = numeric_limits<T>::max() / 2;","template<class t,class u>bool mmax(t&a,u b){if(a<b)a=b;return a<b;}","template<class t,class u>bool mmin(t&a,u b){if(b<a)a=b;return b<a;}","template<class t> using vc=vector<t>;","template<class t> using vvc=vc<vc<t>>;","using li = long long;","using vi = vc<int>;","using ii = pair<int,int>;","// ---- しゃけ ツナマヨ ('-')7","","int main(){_","","	auto solve=[&](){","","	};","	//int t; cin>>t; while(t--)","	solve();","}",]
},
"DSUPersistent.cpp": {
	"prefix": "DSUPersistent.cpp" ,
	"body": ["struct Dsu {","  vector<int> parents;","  vector<int> sizes;","  vector<array<int, 2>> history;","	int tot;","","  Dsu(int n=1) {","    parents.resize(n);","    iota(all(parents), 0);","    sizes.assign(n, 1);","		tot = n;","  }","","  int find(int x) {","    if (x == parents[x]) { return x; }","    return find(parents[x]);","  }","","  bool unite(int x, int y) {","    x = find(x); y = find(y);","    if (x == y) { return 0; }","    if (sizes[x] > sizes[y]) { swap(x, y); }","    parents[x] = y;","    sizes[y] += sizes[x];","    history.push_back({x, y});","		tot--;","		return 1;","  }","","  void rollback() {","    if(history.empty())return;","    auto [x, y] = history.back(); history.pop_back();","    parents[x] = x;","		tot++;","    sizes[y] -= sizes[x];","  }","};","","struct Query{","	int a,b,c;","	Query(int a, int b):a(a),b(b),c(0){}","};","","struct QTree{","	#define mid (l + r) / 2","	#define left(u) (u + 1)","  #define right(u) (u + ((mid - l + 1) << 1))","	vc<vc<Query>> st;","	Dsu dsu;","	QTree(int n, int v):st(2*n+5){","			dsu = Dsu(v);","	}","","	void add(int u, int l, int r, int ll, int rr, Query v){","		if(r < ll or l > rr or l>r) return;","		if(ll ==l and r == rr){","			st[u].pb(v);","			return;","		}","		add(left(u), l, mid, ll, min(rr,mid), v);","		add(right(u), mid+1, r, max(ll,mid+1), rr, v);","	}","","	void dfs(int u, int l, int r, vc<int>&ans){","		for(auto &i:st[u])i.c=dsu.unite(i.a, i.b);","		if(l==r)ans[l]=dsu.tot;","		else{","			dfs(left(u),l,mid,ans);","			dfs(right(u),mid+1,r,ans);","		}","		for(auto &i:st[u])if(i.c)dsu.rollback();","	}","","};",]
},
"Segtree-Noimi.cpp": {
	"prefix": "Segtree-Noimi.cpp" ,
	"body": ["","template <typename Monoid> struct SegmentTree {","   using F = function<Monoid(Monoid, Monoid)>;","","   int sz;","   vector<Monoid> seg;","","   const F f;","   const Monoid M1;","","   SegmentTree(int n, const F f, const Monoid &M1) : f(f), M1(M1) {","       sz = 1;","       while(sz < n) sz <<= 1;","       seg.assign(2 * sz, M1);","   }","","   void set(int k, const Monoid &x) { seg[k + sz] = x; }","","   void build() {","       for(int k = sz - 1; k > 0; k--) { seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]); }","   }","","   void update(int k, const Monoid &x) {","       k += sz;","       seg[k] = x;","       while(k >>= 1) { seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]); }","   }","","   Monoid query(int a, int b) {","       Monoid L = M1, R = M1;","       for(a += sz, b += sz; a < b; a >>= 1, b >>= 1) {","           if(a & 1) L = f(L, seg[a++]);","           if(b & 1) R = f(seg[--b], R);","       }","       return f(L, R);","   }","","   Monoid operator[](const int &k) const { return seg[k + sz]; }","","   template <typename C> int find_subtree(int a, const C &check, Monoid &M, bool type) {","       while(a < sz) {","           Monoid nxt = type ? f(seg[2 * a + type], M) : f(M, seg[2 * a + type]);","           if(check(nxt))","               a = 2 * a + type;","           else","               M = nxt, a = 2 * a + 1 - type;","       }","       return a - sz;","   }","","   // [a,x] が条件を満たす最小のx","   template <typename C> int find_first(int a, const C &check) {","       Monoid L = M1;","       if(a <= 0) {","           if(check(f(L, seg[1]))) return find_subtree(1, check, L, false);","           return -1;","       }","       int b = sz;","       for(a += sz, b += sz; a < b; a >>= 1, b >>= 1) {","           if(a & 1) {","               Monoid nxt = f(L, seg[a]);","               if(check(nxt)) return find_subtree(a, check, L, false);","               L = nxt;","               ++a;","           }","       }","       return -1;","   }","","   // [x,b) が条件を満たす最大のx","   template <typename C> int find_last(int b, const C &check) {","       Monoid R = M1;","       if(b >= sz) {","           if(check(f(seg[1], R))) return find_subtree(1, check, R, true);","           return -1;","       }","       int a = sz;","       for(b += sz; a < b; a >>= 1, b >>= 1) {","           if(b & 1) {","               Monoid nxt = f(seg[--b], R);","               if(check(nxt)) return find_subtree(b, check, R, true);","               R = nxt;","           }","       }","       return -1;","   }","   void print(int n) {","       for(int i = 0; i < n; i++) { cerr << seg[i + sz] << \" \"; }","       cerr << ENDL;","   }","};",]
},
"SuffixArray.cpp": {
	"prefix": "SuffixArray.cpp" ,
	"body": ["// Suffix Array / Longest Common Prefix Array Construction","// Comlexity: O(N(log N)^2)","template<typename T>","struct SuffixArray","{","    T S;                    // size: N","    std::vector<int> SA;    // Suffix Array (size: N + 1, SA[0] == N) SA[i] means S[SA[i]:]","    std::vector<int> rank;  // Rank (inverse of SA) (size: N + 1, rank[N] == 0)","    std::vector<int> lcp;   // Longest Common Prefix Array (size: N) betw. S[SA[i]:] & S[SA[i + 1]:]","","    SuffixArray(const T &str, bool gen_lcp = true) : S(str) {","        int N = S.size();","        SA.resize(N + 1);","        std::iota(SA.begin(), SA.end(), 0);","        rank.assign(N + 1, -1);","        for (int i = 0; i < N; i++) rank[i] = S[i];","        int _ord_mm = 1;","","        auto _comp_suffarr = [&](int i, int j) {","            if (rank[i] != rank[j])","                return rank[i] < rank[j];","            int ri = i + _ord_mm < (int)rank.size() ? rank[i + _ord_mm] : -1;","            int rj = j + _ord_mm < (int)rank.size() ? rank[j + _ord_mm] : -1;","            return ri < rj;","        };","        std::vector<int> tmp(N + 1);","        for (_ord_mm = 1; _ord_mm <= N; _ord_mm *= 2) {","            std::sort(SA.begin(), SA.end(), _comp_suffarr);","            tmp[SA[0]] = 0;","            for (int i = 1; i <= N; i++) {","                tmp[SA[i]] = tmp[SA[i - 1]] + _comp_suffarr(SA[i - 1], SA[i]);","            }","            rank = tmp;","        }","        if (!gen_lcp) return;","","        lcp.assign(N, 0);","        int h = 0;","        for (int i = 0; i < N; i++) {","            int j = SA[rank[i] - 1];","            if (h) h--;","            for (; j + h < N and i + h < N; h++) if (S[j + h] != S[i + h]) break;","            lcp[rank[i] - 1] = h;","        }","    }","};",]
},
"Manacher.cpp": {
	"prefix": "Manacher.cpp" ,
	"body": ["array<vi, 2> manacher(const string& s){","	int n = sz(s);","	array<vi,2> p = {vi(n+1), vi(n)};","	fore(z,0,2) for (int i=0,l=0,r=0; i < n; i++) {","		int t = r-i+!z;","		if (i<r) p[z][i] = min(t, p[z][l+t]);","		int L = i-p[z][i], R = i+p[z][i]-!z;","		while (L>=1 && R+1<n && s[L-1] == s[R+1])","			p[z][i]++, L--, R++;","		if (R>r) l=L, r=R;","	}","	return p;","}",]
},
"Z-function.cpp": {
	"prefix": "Z-function.cpp" ,
	"body": ["template <typename T> vector<int> z_algorithm(vector<T> &s) {","    int n = sz(s);","    vector<int> res(n);","    for(int i = 1, j = 0; i < n; i++) {","        if(i + res[i - j] < j + res[j]) res[i] = res[i - j];","        else {","            int k = max(0, j + res[j] - i);","            while(i + k < n and s[k] == s[i + k]) ++k;","            res[i] = k, j = i;","        }","    }","    res[0] = n;","    return res;","}",]
},
"SuffixAutomaton.cpp": {
	"prefix": "SuffixAutomaton.cpp" ,
	"body": ["struct SuffixAutomaton {","    struct Node {","        unordered_map<char, int> next;","        int link, len;","    };","    vector<Node> nodes;","    int last;","","    SuffixAutomaton() {","        nodes.push_back({{}, -1, 0});","        last = 0;","    }","","    void push(char c) {","        int new_node = sz(nodes);","        nodes.push_back({{}, -1, nodes[last].len + 1});","        int p = last;","        while (p != -1 && nodes[p].next.find(c) == nodes[p].next.end()) {","            nodes[p].next[c] = new_node;","            p = nodes[p].link;","        }","        int q = (p == -1 ? 0 : nodes[p].next[c]);","        if (p == -1 || nodes[p].len + 1 == nodes[q].len) nodes[new_node].link = q;","        else {","            int new_q = sz(nodes);","            nodes.push_back({nodes[q].next, nodes[q].link, nodes[p].len + 1});","            nodes[q].link = new_q;","            nodes[new_node].link = new_q;","            while (p != -1 && nodes[p].next[c] == q) {","                nodes[p].next[c] = new_q;","                p = nodes[p].link;","            }","        }","        last = new_node;","    }","};",]
},
"AhoRec.cpp": {
	"prefix": "AhoRec.cpp" ,
	"body": ["","struct vertex {","  map<char,int> next,go;","  int p,link,exit;","  char pch;","  bool leaf;","  vertex(int p=-1, char pch=-1):p(p),pch(pch),exit(-2),link(-1),leaf(0){}","};","","vector<vertex> t;","void aho_ini(){ t.clear();t.pb(vertex()); }","int add(string s, int id){","  int v=0;","  for(char c:s){","    if(!t[v].next.count(c)){","      t[v].next[c]=t.size();","      t.pb(vertex(v,c));","    }","    v=t[v].next[c];","  }","  t[v].leaf = 1;","  return v;","}","int go(int v, char c);","int get_link(int v){","  if(t[v].link<0)","    if(!v||!t[v].p)t[v].link=0;","    else t[v].link=go(get_link(t[v].p),t[v].pch);","  return t[v].link;","}","int go(int v, char c){","  if(!t[v].go.count(c))","    if(t[v].next.count(c))t[v].go[c]=t[v].next[c];","    else t[v].go[c]=v==0?0:go(get_link(v),c);","  return t[v].go[c];","}",]
},
"RollingHash.cpp": {
	"prefix": "RollingHash.cpp" ,
	"body": ["","struct rolling_hash{"," // !!! ハッシュはullで受け取ること !!!"," // 文字列の中に0があると，その値が影響しなくなって壊れるので注意！"," // generate_base は結構遅いので，何回も呼び出す必要がある場合は何度も呼ばない方が良い"," typedef unsigned int ui;"," typedef unsigned long long ull;",""," const ull MASK30 = (1ull<<30) - 1;"," const ull MASK31 = (1ull<<31) - 1;"," const ull MOD = (1ull<<61) - 1;"," const ull POSITIVISER = MOD * ((1ull<<3) - 1);"," ui base;"," int n;"," vector<ull> pw, hs;",""," rolling_hash(){}",""," rolling_hash(const string &s, int bs){","   // set base","   base = (ui)bs;","","   n = s.size();","   hs.assign(n+1, 0);","   pw.assign(n+1, 0);","   hs[0] = 0;","   pw[0] = 1;","   for(int i=0;i<n;i++){","     pw[i+1] = calc_mod(mul(pw[i], base));","     hs[i+1] = calc_mod(mul(hs[i], base) + s[i]);","   }"," }",""," ull hash(int l, int r){","   return calc_mod(hs[r] + POSITIVISER - mul(hs[l], pw[r-l]));"," }",""," ull mul(ull l, ull r){","   ull lu = l>>31;","   ull ld = l & MASK31;","   ull ru = r>>31;","   ull rd = r & MASK31;","   ull middle_bit = ld * ru + lu * rd;","   return ((lu*ru)<<1) +ld*rd + ((middle_bit & MASK30) << 31) + (middle_bit>>30);"," }",""," ull mul(ull l, ui r){","   ull lu = l>>31;","   ull rd = r & MASK31;","   ull middle_bit = lu * rd;","   return (l & MASK31) * rd + ((middle_bit & MASK30)<<31) + (middle_bit>>30);"," }",""," ull calc_mod(ull val){","   val = (val & MOD) + (val>>61);","   if(val > MOD) val -= MOD;","   return val;"," }","};","","int generate_base(){"," random_device seed_gen;"," mt19937_64 rnd(seed_gen());"," uniform_int_distribution<int> dist(129, INT_MAX);"," int base = dist(rnd);"," return base;","}",]
},
"AhoC.cpp": {
	"prefix": "AhoC.cpp" ,
	"body": ["const int A = 26;","struct vertex {","	vi next,go,leaf;","	int p,link,nl;","	char pch;","	vertex(int p=-1, char pch=-1):p(p),pch(pch),link(-1),nl(-1), next(A,-1),go(A,0){}","};","vector<vertex> t;","void aho_ini(){t.clear();t.pb(vertex());}","void add(string s, int id){","	int v=0;","	for(auto x:s){","		int c = x-'a';","		if(t[v].next[c]==-1){","			t[v].next[c]=t[v].go[c]=sz(t);","			t.pb(vertex(v,c));","		}","		v=t[v].next[c];","	}","	t[v].leaf.pb(id);","}","","int go(int v, int c){return t[v].go[c];}","","void BFS(){","	queue<int>q;","	q.push(0);","	t[0].link=t[0].nl=0;","	while(!q.empty()){","		int x = q.front(); q.pop();","		fore(c,0,A){","			if(t[x].next[c]==-1)continue;","			int y = t[x].next[c];","			t[y].link=x?t[t[x].link].go[c]:0;","			int link = t[y].link;","			t[y].nl = sz(t[link].leaf)?link:t[link].nl;","			for(int i = 0; i<A; i++)if(t[y].next[i]==-1)t[y].go[i]=t[link].go[i];","			q.push(y);","		}","	}","}",]
},
"LinkCutTree.cpp": {
	"prefix": "LinkCutTree.cpp" ,
	"body": ["struct SplayTree {","  struct Node {","    int ch[2] = {0, 0}, p = 0;","    long long self = 0, path = 0;        // Path aggregates","    long long sub = 0, vir = 0;          // Subtree aggregates","    bool flip = 0;                       // Lazy tags","  };","  vector<Node> T;","","  SplayTree(int n) : T(n + 1) {}","","  void push(int x) {","    if (!x || !T[x].flip) return;","    int l = T[x].ch[0], r = T[x].ch[1];","","    T[l].flip ^= 1, T[r].flip ^= 1;","    swap(T[x].ch[0], T[x].ch[1]);","    T[x].flip = 0;","  }","","  void pull(int x) {","    int l = T[x].ch[0], r = T[x].ch[1]; push(l); push(r);","","    T[x].path = T[l].path + T[x].self + T[r].path;","    T[x].sub = T[x].vir + T[l].sub + T[r].sub + T[x].self;","  }","","  void set(int x, int d, int y) {","    T[x].ch[d] = y; T[y].p = x; pull(x);","  }","","  void splay(int x) {","    auto dir = [&](int x) {","      int p = T[x].p; if (!p) return -1;","      return T[p].ch[0] == x ? 0 : T[p].ch[1] == x ? 1 : -1;","    };","    auto rotate = [&](int x) {","      int y = T[x].p, z = T[y].p, dx = dir(x), dy = dir(y);","      set(y, dx, T[x].ch[!dx]);","      set(x, !dx, y);","      if (~dy) set(z, dy, x);","      T[x].p = z;","    };","    for (push(x); ~dir(x); ) {","      int y = T[x].p, z = T[y].p;","      push(z); push(y); push(x);","      int dx = dir(x), dy = dir(y);","      if (~dy) rotate(dx != dy ? x : y);","      rotate(x);","    }","  }","};","","struct LinkCut : SplayTree {","  LinkCut(int n) : SplayTree(n) {}","","  int access(int x) {","    int u = x, v = 0;","    for (; u; v = u, u = T[u].p) {","      splay(u);","      int& ov = T[u].ch[1];","      T[u].vir += T[ov].sub;","      T[u].vir -= T[v].sub;","      ov = v; pull(u);","    }","    return splay(x), v;","  }","","  void reroot(int x) {","    access(x); T[x].flip ^= 1; push(x);","  }","","  void Link(int u, int v) {","    reroot(u); access(v);","    T[v].vir += T[u].sub;","    T[u].p = v; pull(v);","  }","","  void Cut(int u, int v) {","    reroot(u); access(v);","    T[v].ch[0] = T[u].p = 0; pull(v);","  }","","  // Rooted tree LCA. Returns 0 if u and v arent connected.","  int LCA(int u, int v) {","    if (u == v) return u;","    access(u); int ret = access(v);","    return T[u].p ? ret : 0;","  }","","  // Query subtree of u where v is outside the subtree.","  long long Subtree(int u, int v) {","    reroot(v); access(u); return T[u].vir + T[u].self;","  }","","  // Query path [u..v]","  long long Path(int u, int v) {","    reroot(u); access(v); return T[v].path;","  }","","  // Update vertex u with value v","  void Update(int u, long long v) {","    access(u); T[u].self = v; pull(u);","  }","};",]
},
"LazySegmentTree.cpp": {
	"prefix": "LazySegmentTree.cpp" ,
	"body": ["template <typename T = int, typename L = int>  LazyST{","  #define mid (l + r)/2","  #define left(u) (u + 1)","  #define right(u) (u + ((mid - l + 1) << 1))","  vector<T>st;  T bad;","  vector<L>lazy; L nulo;","","  T op(T a, T b){return a+b; } // operacion de merge","  T cmp(T a, T b){return a+b; } //operacion en query","","","  LazyST(int n, T ini, L nulo, T bad):st(2*n,ini), lazy(2*n,nulo) nulo(nulo), bad(bad){}","","  void push(int u, int l, int r){","    if(l<r and lazy[u]!=nulo){","      st[left(u)] += lazy[u];","      st[right(u)] += lazy[u];","","      lazy[left(u)] += lazy[u];","      lazy[right(u)] += lazy[u];","","      lazy[u]= nulo;","    }","  }","","  void update(int u, int l, int r, int ll, int rr, T x){","    push(u, l, r);","    if(r < ll or l > rr or l>r) return;","    if(ll <= l and r <= rr){","      //","      return;","    }","    update(left(u), l, mid, ll, rr, x);","    update(right(u), mid + 1, r, ll, rr, x);","    st[u] = op(st[left(u)],st[right(u)]);","  }","","  T query(int u, int l, int r, int ll, int rr){","    push(u, l, r);","    if(r < ll or l > rr or l>r) return bad;","    if(ll <= l and r <= rr)return st[u];","    return cmp(query(left(u),l,mid,ll,rr),query(right(u),mid+1,r,ll,rr));","  }","};",]
},
"DSU.cpp": {
	"prefix": "DSU.cpp" ,
	"body": ["template <typename T = int> struct UnionFind {","    vector<int> pr;","    vector<int> sz;","    vector<T> data;","","    UnionFind(int n, T def) {","        pr.assign(n, -1);","        sz.assign(n, 1);","        data.assign(n,def);","    }","","    bool unite(int x, int y) {","        x = find(x), y = find(y);","        if(x == y) return false;","        if(size(x) < size(y)) swap(x, y);","        sz[x] += sz[y];","        pr[y] = x;","        data[x]+=data[y]; //edit","        return true;","    }","","    bool same(int x, int y) { return find(x) == find(y); }","","    int find(int x) {","        if(pr[x] < 0) return x;","        return (pr[x] = find(pr[x]));","    }","","    int size(int x) { return sz[find(x)]; }","};",]
},
"PersistentDSU.cpp": {
	"prefix": "PersistentDSU.cpp" ,
	"body": ["struct Dsu {","  vector<int> parents;","  vector<int> sizes;","  vector<array<int, 2>> history;","  vector<int> checkpoints;","","  Dsu(int n) {","    parents.resize(n);","    iota(all(parents), 0);","    sizes.assign(n, 1);","  }","","  int find(int x) {","    if (x == parents[x]) { return x; }","    return find(parents[x]);","  }","","  void unite(int x, int y) {","    x = find(x); y = find(y);","    if (x == y) { return; }","    if (sizes[x] > sizes[y]) { swap(x, y); }","","    parents[x] = y;","    sizes[y] += sizes[x];","    history.push_back({x, y});","  }","","  void persist() {","    checkpoints.push_back(history.size());","  }","","  void rollback() {","    int c = checkpoints.back(); checkpoints.pop_back();","    while ((int)history.size() > c) {","      auto [x, y] = history.back(); history.pop_back();","      parents[x] = x;","      sizes[y] -= sizes[x];","    }","  }","};",]
},
"BIT.cpp": {
	"prefix": "BIT.cpp" ,
	"body": ["template <typename T> struct BinaryIndexedTree {","    vector<T> data;","    BinaryIndexedTree(int sz) { data.assign(++sz, 0); }","    T query(int k) {","        T ret = 0;","        for(++k; k > 0; k -= k & -k) ret += data[k];","        return (ret);","    }","    void add(int k, T x) {","        for(++k; k < data.size(); k += k & -k) data[k] += x;","    }","};","#define BIT BinaryIndexedTree",]
},
"Queue.cpp": {
	"prefix": "Queue.cpp" ,
	"body": ["template <typename T> struct qiu{","	stack<pair<T,T>> s1,s2;","	T query(){","		T mini;","		if (s1.empty() || s2.empty()) mini = s1.empty() ? s2.top().s : s1.top().s;","		else mini = min(s1.top().s, s2.top().s);","		return mini;","	}","","	void pop(){","		if (s2.empty())while (!s1.empty()) {","        T e = s1.top().f;","        s1.pop();","        T mini = s2.empty() ? e : min(e, s2.top().s);","        s2.push({e, mini});","    	}","		T rem = s2.top().f;","		s2.pop();","	}","","	void add(T new_e){","		T mini = s1.empty() ? new_e : min(new_e, s1.top().second);","		s1.push({new_e, mini});","	}","};",]
},
"Treap.cpp": {
	"prefix": "Treap.cpp" ,
	"body": ["","typedef struct item *pitem;","struct item {","	int pr,cnt;","	int val;","","	pitem l,r;","	item(int val): pr(rnd(int(2e6))),cnt(1),val(val),l(0),r(0){}","};","void push(pitem it){","	if(it){","	}","}","int cnt(pitem it){return it?it->cnt:0;}","","void refresh(pitem it){","	if(it){","		it->cnt=cnt(it->l)+cnt(it->r)+1;","	}","}","void merge(pitem& t, pitem l, pitem r){","	push(l);push(r);","	if(!l||!r)t=l?l:r;","	else if(l->pr>r->pr)merge(l->r,l->r,r),t=l;","	else merge(r->l,l,r->l),t=r;","	refresh(t);","}","void split(pitem t, pitem& l, pitem& r, int sz){","	if(!t){l=r=0;return;}","	push(t);","	if(sz<=cnt(t->l))split(t->l,l,t->l,sz),r=t;","	else split(t->r,t->r,r,sz-1-cnt(t->l)),l=t;","	refresh(t);","}","void output(pitem t){","	if(!t)return;","	push(t);","	output(t->l);cout<<t->val<<\" \";output(t->r);","}","","","};",]
},
"SparseTable.cpp": {
	"prefix": "SparseTable.cpp" ,
	"body": ["int K = 10;","auto oper =[](int a, int b){return ;};","int st[K][1<<K];","void st_init(vi a){","  int n = sz(a);","	st[0]=a;","	fore(k,1,K)fore(i,0,n-(1<<k)+1)st[k][i]=oper(st[k-1][i],st[k-1][i+(1<<(k-1))]);","}","int st_query(int s, int e){","	int k=31-__builtin_clz(e-s);","	return oper(st[k][s],st[k][e-(1<<k)]);","}",]
},
"SegTreeIterativo.cpp": {
	"prefix": "SegTreeIterativo.cpp" ,
	"body": ["template<typename T>","struct SegmentTree{","private:","    int n;","    T E;","    vector<T> node;","    inline void updatef(T& x,T& y){","        x = y;","    }","    inline T queryf(T& x,T& y){","        return max(x,y);","    }","","public:","    SegmentTree(int sz,T E_):E(E_){","        n=1;","        while(n<sz)n<<=1;","        node.resize(2*n-1,E);","    }","","    SegmentTree(vector<T>& A,T E_):E(E_){","        int sz=A.size();","        n=1;","        while(n<sz)n<<=1;","        node.resize(2*n-1,E);","        fore(i,0,sz)node[i+n-1]=A[i];","        for(int i=n-2;i>=0;--i){","            node[i]=queryf(node[2*i+1], node[2*i+2]);","        }","    }","    void update(int k,T x){","        k+=n-1;","        updatef(node[k],x);","        while(k>0){","            k=(k-1)/2;","            node[k]=queryf(node[2*k+1], node[2*k+2]);","        }","    }","       //[a,b)での和を返す","    T get(int a,int b,int k=0,int l=0,int r=-1){","        if(r<0)r=n;","        if(r<=a||b<=l)return E;","        if(a<=l&&r<=b)return node[k];","        T xl=get(a,b,2*k+1,l,(l+r)/2);","        T xr=get(a,b,2*k+2,(l+r)/2,r);","        return queryf(xl, xr);","    }","    int find(int x, int k = 0) {","        if(k >= n-1)return k - n + 1;","        if(node[2*k+1]>=x)return find(x, 2*k+1);","        return find(x, 2*k+2);","    }","};",]
},
"WUF.cpp": {
	"prefix": "WUF.cpp" ,
	"body": ["struct C{","	set<ii>s;","	int query(int u){","		auto p = s.lower_bound(ii{u,-1});","		if(p==s.begin())return 0;","		return prev(p)->s;","	}","	void add(int u, int d){","		int x = query(u);","		if(x<d){","			auto p = s.lower_bound(ii{u,-1});","			while(p!=s.end() and p->s<=d)p = s.erase(p);","			s.insert(ii{u,d});","		}","	}","};",]
},
"Segtree.cpp": {
	"prefix": "Segtree.cpp" ,
	"body": ["template <typename T = int> struct ST{","	#define mid (l + r) / 2","	#define left(u) (u + 1)","	#define right(u) (u + ((mid - l + 1) << 1))","	vector<T> st; T bad;","	ST(int n, T ini, T bad):st(2*n, ini),bad(bad){}","","	T f(T a, T b){","		return max(a,b);","	}","","	void update(int u, int l, int r, int v, T value){","		if(l>r)return;","		if(l==r){st[u]=value; return;}","		if(v<=mid)update(left(u), l , mid , v , value);","		else update(right(u), mid+1 , r , v , value);","		st[u]=f(st[left(u)], st[right(u)]);","	}","","	T query(int u, int l, int r, int ll, int rr){","		if(l>rr or r<ll or l>r)return bad;","		if(ll<=l and r<=rr)return st[u];","		return f(query(left(u), l , mid , ll , rr) , query(right(u), mid+1 , r , ll , rr) );","	}","","};",]
},
"CRT.cpp": {
	"prefix": "CRT.cpp" ,
	"body": ["// 例えば -17 を 5 で割った余りは本当は 3 (-17 ≡ 3 (mod. 5))","inline long long mod(long long a, long long m) {","    return (a % m + m) % m;","}","","// 拡張 Euclid の互除法","// ap + bq = gcd(a, b) となる (p, q) を求め、d = gcd(a, b) をリターンします","long long extGcd(long long a, long long b, long long &p, long long &q) {","    if (b == 0) { p = 1; q = 0; return a; }","    long long d = extGcd(b, a%b, q, p);","    q -= a/b * p;","    return d;","}","","// リターン値を (r, m) とすると解は x ≡ r (mod. m)","// 解なしの場合は (0, -1) をリターン","pair<long long, long long> ChineseRem(long long b1, long long m1, long long b2, long long m2) {","  long long p, q;","  long long d = extGcd(m1, m2, p, q); // p is inv of m1/d (mod. m2/d)","  if ((b2 - b1) % d != 0) return make_pair(0, -1);","  long long m = m1 * (m2/d); // lcm of (m1, m2)","  long long tmp = (b2 - b1) / d * p % (m2/d);","  long long r = mod(b1 + m1 * tmp, m);","  return make_pair(r, m);","}",]
},
"Geometry.cpp": {
	"prefix": "Geometry.cpp" ,
	"body": ["#define double long double","","using Real = double;","using Point = complex< Real >;","const Real EPS = 1e-8, PI = acos(-1);","","inline bool eq(Real a, Real b) { return fabs(b - a) < EPS; }","inline bool eq(Point a,Point b){return (eq(a.imag(),b.imag())and eq(a.real(),b.real()));}","","Point operator*(const Point &p, const Real &d) {","  return Point(real(p) * d, imag(p) * d);","}","","istream &operator>>(istream &is, Point &p) {","  Real a, b;","  is >> a >> b;","  p = Point(a, b);","  return is;","}","","ostream &operator<<(ostream &os, Point &p) {","  return os << fixed << setprecision(10) << p.real() << \" \" << p.imag();","}","","// 点 p を反時計回りに theta 回転","Point rotate(Real theta, const Point &p) {","  return Point(cos(theta) * p.real() - sin(theta) * p.imag(), sin(theta) * p.real() + cos(theta) * p.imag());","}","","Real radian_to_degree(Real r) {","  return (r * 180.0 / PI);","}","","Real degree_to_radian(Real d) {","  return (d * PI / 180.0);","}","","// a-b-c の角度のうち小さい方を返す","Real get_angle(const Point &a, const Point &b, const Point &c) {","  const Point v(b - a), w(c - b);","  Real alpha = atan2(v.imag(), v.real()), beta = atan2(w.imag(), w.real());","  if(alpha > beta) swap(alpha, beta);","  Real theta = (beta - alpha);","  return min(theta, 2 * acos(-1) - theta);","}","","namespace std {","  bool operator<(const Point &a, const Point &b) {","    return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();","  }","}","","","struct Line {","  Point a, b;","","  Line() = default;","","  Line(Point a, Point b) : a(a), b(b) {}","","  Line(Real A, Real B, Real C) // Ax + By = C","  {","    if(eq(A, 0)) a = Point(0, C / B), b = Point(1, C / B);","    else if(eq(B, 0)) b = Point(C / A, 0), b = Point(C / A, 1);","    else a = Point(0, C / B), b = Point(C / A, 0);","  }","","  friend ostream &operator<<(ostream &os, Line &p) {","    return os << p.a << \" to \" << p.b;","  }","","  friend istream &operator>>(istream &is, Line &a) {","    return is >> a.a >> a.b;","  }","};","","struct Segment : Line {","  Segment() = default;","","  Segment(Point a, Point b) : Line(a, b) {}","};","","struct Circle {","  Point p;","  Real r;","","  Circle() = default;","","  Circle(Point p, Real r) : p(p), r(r) {}","};","","using Points = vector< Point >;","using Polygon = vector< Point >;","using Segments = vector< Segment >;","using Lines = vector< Line >;","using Circles = vector< Circle >;","","Real cross(const Point &a, const Point &b) {","  return real(a) * imag(b) - imag(a) * real(b);","}","","Real dot(const Point &a, const Point &b) {","  return real(a) * real(b) + imag(a) * imag(b);","}","","// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_C","// 点の回転方向","int ccw(const Point &a, Point b, Point c) {","  b = b - a, c = c - a;","  if(cross(b, c) > EPS) return +1;  // \"COUNTER_CLOCKWISE\"","  if(cross(b, c) < -EPS) return -1; // \"CLOCKWISE\"","  if(dot(b, c) < 0) return +2;      // \"ONLINE_BACK\"","  if(norm(b) < norm(c)) return -2;  // \"ONLINE_FRONT\"","  return 0;                         // \"ON_SEGMENT\"","}","","// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A","// 平行判定","bool parallel(const Line &a, const Line &b) {","  return eq(cross(a.b - a.a, b.b - b.a), 0.0);","}","","// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A","// 垂直判定","bool orthogonal(const Line &a, const Line &b) {","  return eq(dot(a.a - a.b, b.a - b.b), 0.0);","}","","// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_A","// 射影","// 直線 l に p から垂線を引いた交点を求める","Point projection(const Line &l, const Point &p) {","  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);","  return l.a + (l.a - l.b) * t;","}","","Point projection(const Segment &l, const Point &p) {","  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);","  return l.a + (l.a - l.b) * t;","}","","// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_B","// 反射","// 直線 l を対称軸として点 p  と線対称にある点を求める","Point reflection(const Line &l, const Point &p) {","  return p + (projection(l, p) - p) * 2.0;","}","","bool intersect(const Line &l, const Point &p) {","  return abs(ccw(l.a, l.b, p)) != 1;","}","","bool intersect(const Line &l, const Line &m) {","  return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;","}","","bool intersect(const Segment &s, const Point &p) {","  return ccw(s.a, s.b, p) == 0;","}","","bool intersect(const Line &l, const Segment &s) {","  return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;","}","","Real distance(const Line &l, const Point &p);","","bool intersect(const Circle &c, const Line &l) {","  return distance(l, c.p) <= c.r + EPS;","}","","bool intersect(const Circle &c, const Point &p) {","  return abs(abs(p - c.p) - c.r) < EPS;","}","","// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B","bool intersect(const Segment &s, const Segment &t) {","  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;","}","","int intersect(const Circle &c, const Segment &l) {","  if(norm(projection(l, c.p) - c.p) - c.r * c.r > EPS) return 0;","  auto d1 = abs(c.p - l.a), d2 = abs(c.p - l.b);","  if(d1 < c.r + EPS && d2 < c.r + EPS) return 0;","  if(d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS) return 1;","  const Point h = projection(l, c.p);","  if(dot(l.a - h, l.b - h) < 0) return 2;","  return 0;","}","","// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_A&lang=jp","int intersect(Circle c1, Circle c2) {","  if(c1.r < c2.r) swap(c1, c2);","  Real d = abs(c1.p - c2.p);","  if(c1.r + c2.r < d) return 4;","  if(eq(c1.r + c2.r, d)) return 3;","  if(c1.r - c2.r < d) return 2;","  if(eq(c1.r - c2.r, d)) return 1;","  return 0;","}","","Real distance(const Point &a, const Point &b) {","  return abs(a - b);","}","","Real distance(const Line &l, const Point &p) {","  return abs(p - projection(l, p));","}","","Real distance(const Line &l, const Line &m) {","  return intersect(l, m) ? 0 : distance(l, m.a);","}","","Real distance(const Segment &s, const Point &p) {","  Point r = projection(s, p);","  if(intersect(s, r)) return abs(r - p);","  return min(abs(s.a - p), abs(s.b - p));","}","","// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_D","Real distance(const Segment &a, const Segment &b) {","  if(intersect(a, b)) return 0;","  return min({distance(a, b.a), distance(a, b.b), distance(b, a.a), distance(b, a.b)});","}","","Real distance(const Line &l, const Segment &s) {","  if(intersect(l, s)) return 0;","  return min(distance(l, s.a), distance(l, s.b));","}","","Point crosspoint(const Line &l, const Line &m) {","  Real A = cross(l.b - l.a, m.b - m.a);","  Real B = cross(l.b - l.a, l.b - m.a);","  if(eq(abs(A), 0.0) && eq(abs(B), 0.0)) return m.a;","  return m.a + (m.b - m.a) * B / A;","}","","// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_C","Point crosspoint(const Segment &l, const Segment &m) {","  return crosspoint(Line(l), Line(m));","}","","// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_D","pair< Point, Point > crosspoint(const Circle &c, const Line l) {","  Point pr = projection(l, c.p);","  Point e = (l.b - l.a) / abs(l.b - l.a);","  if(eq(distance(l, c.p), c.r)) return {pr, pr};","  double base = sqrt(c.r * c.r - norm(pr - c.p));","  return {pr - e * base, pr + e * base};","}","","pair< Point, Point > crosspoint(const Circle &c, const Segment &l) {","  Line aa = Line(l.a, l.b);","  if(intersect(c, l) == 2) return crosspoint(c, aa);","  auto ret = crosspoint(c, aa);","  if(dot(l.a - ret.first, l.b - ret.first) < 0) ret.second = ret.first;","  else ret.first = ret.second;","  return ret;","}","","// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_E","pair< Point, Point > crosspoint(const Circle &c1, const Circle &c2) {","  Real d = abs(c1.p - c2.p);","  Real a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));","  Real t = atan2(c2.p.imag() - c1.p.imag(), c2.p.real() - c1.p.real());","  Point p1 = c1.p + Point(cos(t + a) * c1.r, sin(t + a) * c1.r);","  Point p2 = c1.p + Point(cos(t - a) * c1.r, sin(t - a) * c1.r);","  return {p1, p2};","}","","// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_F","// 点 p を通る円 c の接線","pair< Point, Point > tangent(const Circle &c1, const Point &p2) {","  return crosspoint(c1, Circle(p2, sqrt(norm(c1.p - p2) - c1.r * c1.r)));","}","","// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_G","// 円 c1, c2 の共通接線","Lines tangent(Circle c1, Circle c2) {","  Lines ret;","  if(c1.r < c2.r) swap(c1, c2);","  Real g = norm(c1.p - c2.p);","  if(eq(g, 0)) return ret;","  Point u = (c2.p - c1.p) / sqrt(g);","  Point v = rotate(PI * 0.5, u);","  for(int s : {-1, 1}) {","    Real h = (c1.r + s * c2.r) / sqrt(g);","    if(eq(1 - h * h, 0)) {","      ret.emplace_back(c1.p + u * c1.r, c1.p + (u + v) * c1.r);","    } else if(1 - h * h > 0) {","      Point uu = u * h, vv = v * sqrt(1 - h * h);","      ret.emplace_back(c1.p + (uu + vv) * c1.r, c2.p - (uu + vv) * c2.r * s);","      ret.emplace_back(c1.p + (uu - vv) * c1.r, c2.p - (uu - vv) * c2.r * s);","    }","  }","  return ret;","}","","// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_B","// 凸性判定","bool is_convex(const Polygon &p) {","  int n = (int) p.size();","  for(int i = 0; i < n; i++) {","    if(ccw(p[(i + n - 1) % n], p[i], p[(i + 1) % n]) == -1) return false;","  }","  return true;","}","","// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_A","// 凸包","Polygon convex_hull(Polygon &p) {","  int n = (int) p.size(), k = 0;","  if(n <= 2) return p;","  sort(p.begin(), p.end());","  vector< Point > ch(2 * n);","  for(int i = 0; i < n; ch[k++] = p[i++]) {","    while(k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < EPS) --k;","  }","  for(int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {","    while(k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < EPS) --k;","  }","  ch.resize(k - 1);","  return ch;","}","","// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_C","// 多角形と点の包含判定","enum {","  OUT, ON, IN","};","","int contains(const Polygon &Q, const Point &p) {","  bool in = false;","  for(int i = 0; i < Q.size(); i++) {","    Point a = Q[i] - p, b = Q[(i + 1) % Q.size()] - p;","    if(a.imag() > b.imag()) swap(a, b);","    if(a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0) in = !in;","    if(cross(a, b) == 0 && dot(a, b) <= 0) return ON;","  }","  return in ? IN : OUT;","}","","","// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1033","// 線分の重複除去","void merge_segments(vector< Segment > &segs) {","","  auto merge_if_able = [](Segment &s1, const Segment &s2) {","    if(abs(cross(s1.b - s1.a, s2.b - s2.a)) > EPS) return false;","    if(ccw(s1.a, s2.a, s1.b) == 1 || ccw(s1.a, s2.a, s1.b) == -1) return false;","    if(ccw(s1.a, s1.b, s2.a) == -2 || ccw(s2.a, s2.b, s1.a) == -2) return false;","    s1 = Segment(min(s1.a, s2.a), max(s1.b, s2.b));","    return true;","  };","","  for(int i = 0; i < segs.size(); i++) {","    if(segs[i].b < segs[i].a) swap(segs[i].a, segs[i].b);","  }","  for(int i = 0; i < segs.size(); i++) {","    for(int j = i + 1; j < segs.size(); j++) {","      if(merge_if_able(segs[i], segs[j])) {","        segs[j--] = segs.back(), segs.pop_back();","      }","    }","  }","}","","","","// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_C","// 凸多角形の切断","// 直線 l.a-l.b で切断しその左側にできる凸多角形を返す","Polygon convex_cut(const Polygon &U, Line l) {","  Polygon ret;","  for(int i = 0; i < U.size(); i++) {","    Point now = U[i], nxt = U[(i + 1) % U.size()];","    if(ccw(l.a, l.b, now) != -1) ret.push_back(now);","    if(ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {","      ret.push_back(crosspoint(Line(now, nxt), l));","    }","  }","  return (ret);","}","","// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_A","// 多角形の面積","Real area(const Polygon &p) {","  Real A = 0;","  for(int i = 0; i < p.size(); ++i) {","    A += cross(p[i], p[(i + 1) % p.size()]);","  }","  return A * 0.5;","}","","// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_H","// 円と多角形の共通部分の面積","Real area(const Polygon &p, const Circle &c) {","  if(p.size() < 3) return 0.0;","  function< Real(Circle, Point, Point) > cross_area = [&](const Circle &c, const Point &a, const Point &b) {","    Point va = c.p - a, vb = c.p - b;","    Real f = cross(va, vb), ret = 0.0;","    if(eq(f, 0.0)) return ret;","    if(max(abs(va), abs(vb)) < c.r + EPS) return f;","    if(distance(Segment(a, b), c.p) > c.r - EPS) return c.r * c.r * arg(vb * conj(va));","    auto u = crosspoint(c, Segment(a, b));","    vector< Point > tot{a, u.first, u.second, b};","    for(int i = 0; i + 1 < tot.size(); i++) {","      ret += cross_area(c, tot[i], tot[i + 1]);","    }","    return ret;","  };","  Real A = 0;","  for(int i = 0; i < p.size(); i++) {","    A += cross_area(c, p[i], p[(i + 1) % p.size()]);","  }","  return A;","}","","// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_B","// 凸多角形の直径(最遠頂点対間距離)","Real convex_diameter(const Polygon &p) {","  int N = (int) p.size();","  int is = 0, js = 0;","  for(int i = 1; i < N; i++) {","    if(p[i].imag() > p[is].imag()) is = i;","    if(p[i].imag() < p[js].imag()) js = i;","  }","  Real maxdis = norm(p[is] - p[js]);","","  int maxi, maxj, i, j;","  i = maxi = is;","  j = maxj = js;","  do {","    if(cross(p[(i + 1) % N] - p[i], p[(j + 1) % N] - p[j]) >= 0) {","      j = (j + 1) % N;","    } else {","      i = (i + 1) % N;","    }","    if(norm(p[i] - p[j]) > maxdis) {","      maxdis = norm(p[i] - p[j]);","      maxi = i;","      maxj = j;","    }","  } while(i != is || j != js);","  return sqrt(maxdis);","}","","// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_5_A","// 最近点対","Real closest_pair(Points ps) {","  if(ps.size() <= 1) throw (0);","  sort(begin(ps), end(ps));","","  auto compare_y = [&](const Point &a, const Point &b) {","    return imag(a) < imag(b);","  };","  vector< Point > beet(ps.size());","  const Real INF = 1e18;","","  function< Real(int, int) > rec = [&](int left, int right) {","    if(right - left <= 1) return INF;","    int mid = (left + right) >> 1;","    auto x = real(ps[mid]);","    auto ret = min(rec(left, mid), rec(mid, right));","    inplace_merge(begin(ps) + left, begin(ps) + mid, begin(ps) + right, compare_y);","    int ptr = 0;","    for(int i = left; i < right; i++) {","      if(abs(real(ps[i]) - x) >= ret) continue;","      for(int j = 0; j < ptr; j++) {","        auto luz = ps[i] - beet[ptr - j - 1];","        if(imag(luz) >= ret) break;","        ret = min(ret, abs(luz));","      }","      beet[ptr++] = ps[i];","    }","    return ret;","  };","  return rec(0, (int) ps.size());","}",]
},
"Pollard.cpp": {
	"prefix": "Pollard.cpp" ,
	"body": ["","struct Factorize {","    using lll = __int128_t;","    using ll = long long;","    random_device rnd;","    ll modpow(ll a, ll n, ll mod) {","        ll ret = 1;","        while (n > 0) {","            if (n & 1) ret = lll(ret) * lll(a) % lll(mod);","            a = lll(a) * lll(a) % lll(mod);","            n >>= 1;","        }","        return ret;","    }","    ll Rho(ll n) {","        auto f = [&](ll x) { return (lll(x) * lll(x) + lll(1)) % lll(n); };","        while (1) {","            ll x = uniform_int_distribution<ll>(0, n - 1)(rnd);","            ll y = f(x);","            while (1) {","                ll d = gcd(abs(x - y), n);","                if (d == n) break;","                if (1 < d) return d;","                x = f(x);","                y = f(f(y));","            }","        }","    }","    inline bool Miller_Rabin(ll n) {","        if (n == 1) return 0;","        ll d = n - 1, s = 0;","        while (~d & 1) d >>= 1, s++;","        auto check = [&](ll a) {","            ll x = modpow(a, d, n);","            if (x == 1) return 1;","            ll y = n - 1;","            for (int i = 0; i < s; i++) {","                if (x == y) return 1;","                x = lll(x) * lll(x) % lll(n);","            }","            return 0;","        };","        for (auto a :{2, 325, 9375, 28178, 450775, 9780504, 1795265022}) {","            if (a >= n) break;","            if (!check(a)) return 0;","        }","        return 1;","    }","    map<ll,int> operator()(ll n) {","        map<ll, int> ret;","        while (~n & 1) {","            n >>= 1;","            ret[2]++;","        }","        queue<ll> q;","        q.push(n);","        while (sz(q)) {","            ll now = q.front();","            q.pop();","            if (now == 1) continue;","            if (Miller_Rabin(now)) {","                ret[now]++;","                continue;","            }","            ll p = Rho(now);","            q.push(p);","            q.push(now / p);","        }","        return ret;","    }","} factorize;",]
},
"PollardFast.cpp": {
	"prefix": "PollardFast.cpp" ,
	"body": ["using lli = long long int;","lli add(lli a, lli b, lli m){return (a+=b)<m?a:a-m;}","","lli mulmod(lli a, lli b, lli m) {","	lli r = a*b-(lli)((long double)a*b/m+.5)*m;","	return r<0?r+m:r;","}","lli expmod(lli b, lli e, lli m){","	if(!e)return 1;","	lli q=expmod(b,e/2,m);q=mulmod(q,q,m);","	return e&1?mulmod(b,q,m):q;","}","bool is_prime_prob(lli n, int a){","	if(n==a)return true;","	lli s=0,d=n-1;","	while(d%2==0)s++,d/=2;","	lli x=expmod(a,d,n);","	if((x==1)||(x+1==n))return true;","	fore(rep,0,s-1){","		x=mulmod(x,x,n);","		if(x==1)return false;","		if(x+1==n)return true;","	}","	return false;","}","bool rabin(lli n){","	if(n==1) return false;","	int ar[]={2,3,5,7,11,13,17,19,23};","	fore(i,0,9)if(!is_prime_prob(n,ar[i]))return false;","	return true;","}","","const int MAXP=1e6+1;","int sv[MAXP];","","lli rho(lli n){","	static lli s[MAXP];","	while(1){","		lli x=rand()%n,y=x,c=rand()%n;","		lli *px=s,*py=s,v=0,p=1;","		while(1){","			*py++=y=add(mulmod(y,y,n),c,n);","			*py++=y=add(mulmod(y,y,n),c,n);","			if((x=*px++)==y)break;","			lli t=p;","			p=mulmod(p,abs(y-x),n);","			if(!p)return gcd(t,n);","			if(++v==26){","				if((p=gcd(p,n))>1&&p<n)return p;","				v=0;","			}","		}","		if(v&&(p=gcd(p,n))>1&&p<n)return p;","	}","}","void init_sv(){ // Call first","	fore(i,2,MAXP)if(!sv[i])for(lli j=i;j<MAXP;j+=i)sv[j]=i;","}","void fact(lli n, map<lli,int>& f){","	for(auto&& p:f){","		while(n%p.f==0){","			p.s++;","			n/=p.f;","		}","	}","	if(n<MAXP)while(n>1)f[sv[n]]++,n/=sv[n];","	else if(rabin(n))f[n]++;","	else {lli q=rho(n);fact(q,f);fact(n/q,f);}","}",]
},
"GCD.cpp": {
	"prefix": "GCD.cpp" ,
	"body": ["long long extgcd(long long a, long long b, long long &x, long long &y) {","    if(!b) {","        x = 1, y = 0;","        return a;","    }","    long long res = extgcd(b, a % b, y, x);","    y -= a / b * x;","    return res;","}",]
},
"Point.cpp": {
	"prefix": "Point.cpp" ,
	"body": ["struct point {","    long long x, y;","","    point() : x(0), y(0) {}","","    point(long long _x, long long _y) : x(_x), y(_y) {}","","    point& operator+=(const point &other) { x += other.x; y += other.y; return *this; }","    point& operator-=(const point &other) { x -= other.x; y -= other.y; return *this; }","    point& operator*=(long long mult) { x *= mult; y *= mult; return *this; }","","    point operator+(const point &other) const { return point(*this) += other; }","    point operator-(const point &other) const { return point(*this) -= other; }","    point operator*(long long mult) const { return point(*this) *= mult; }","","    bool operator==(const point &other) const { return x == other.x && y == other.y; }","    bool operator!=(const point &other) const { return !(*this == other); }","","    point operator-() const { return point(-x, -y); }","    point rotate90() const { return point(-y, x); }","","    long long norm() const {","        return (long long) x * x + (long long) y * y;","    }","","    long double dist() const {","        return sqrt((long double) norm());","    }","","    bool top_half() const {","        return y > 0 || (y == 0 && x > 0);","    }","","    friend ostream& operator<<(ostream &stream, const point &p) {","        return stream << '(' << p.x << \", \" << p.y << ')';","    }","};","","long long cross(const point &a, const point &b) {","    return (long long) a.x * b.y - (long long) b.x * a.y;","}","","long long dot(const point &a, const point &b) {","    return (long long) a.x * b.x + (long long) a.y * b.y;","}","","const bool CHECK_OVERFLOW64 = false;","","int cross_sign(const point &a, const point &b) {","    if (CHECK_OVERFLOW64) {","        long double double_value = (long double) a.x * b.y - (long double) b.x * a.y;","","        if (abs(double_value) > 1e18)","            return double_value > 0 ? +1 : -1;","    }","","    uint64_t uint64_value = (uint64_t) a.x * b.y - (uint64_t) b.x * a.y;","","    if (uint64_value == 0)","        return 0;","","    return uint64_value >> 63 ? -1 : +1;","}","","bool left_turn_strict(const point &a, const point &b, const point &c) {","    return cross_sign(b - a, c - a) > 0;","}","","bool left_turn_lenient(const point &a, const point &b, const point &c) {","    return cross_sign(b - a, c - a) >= 0;","}","","bool collinear(const point &a, const point &b, const point &c) {","    return cross_sign(b - a, c - a) == 0;","}","","// Returns the signed, doubled area formed by three points in a triangle. Positive when a -> b -> c is a left turn.","long long area_signed_doubled(const point &a, const point &b, const point &c) {","    return cross(b - a, c - a);","}","","long double distance_to_line(const point &p, const point &a, const point &b) {","    assert(a != b);","    return abs(area_signed_doubled(p, a, b)) / (a - b).dist();","}","","long long manhattan_dist(const point &a, const point &b) {","    return (long long) abs(a.x - b.x) + abs(a.y - b.y);","}","","long long infinity_norm_dist(const point &a, const point &b) {","    return max(abs(a.x - b.x), abs(a.y - b.y));","}","","// Sort in increasing order of y, with ties broken in increasing order of x.","bool yx_compare(const point &a, const point &b) {","    return (b - a).top_half();","}","","// Sort in increasing order of angle to the x-axis.","bool angle_compare(const point &a, const point &b) {","    if (a.top_half() ^ b.top_half())","        return a.top_half();","","    return cross_sign(a, b) > 0;","}",]
},
"Matrix.cpp": {
	"prefix": "Matrix.cpp" ,
	"body": ["","template<typename T>","struct Matrix{","	vector<vector<T>> a;","	Matrix(){}","	Matrix(size_t n, size_t m):a(n, vector<T>(m, 0)){}","	Matrix(size_t n):Matrix(n, n){}","	Matrix(vector<vector<T>> a):a(a){}","","	size_t height() const{ return a.size();}","	size_t width() const{return a[0].size();}","","	inline const vector<T> &operator[](size_t k) const{return a[k];}","	inline vector<T> &operator[](size_t k){return a[k];}","","	static Matrix I(size_t n){","		Matrix mat(n);","		for(int i=0; i<n; i++) mat[i][i]=1;","		return mat;","	}","","	Matrix &operator+=(const Matrix &b){","		size_t n=height(), m=width();","		for(int i=0; i<n; i++)for(int j=0; j<m; j++)(*this)[i][j]+=b[i][j];","		return (*this);","	}","	Matrix &operator-=(const Matrix &b){","		size_t n=height(), m=width();","		for(int i=0; i<n; i++)for(int j=0; j<m; j++)(*this)[i][j]-=b[i][j];","		return (*this);","	}","	Matrix &operator*=(const Matrix &b){","		size_t n=height(), m=width(), l=b.width();","		vector<vector<T>> c(n, vector<T>(l, 0));","		for(int i=0; i<n; i++)for(int j=0; j<l; j++)for(int k=0; k<m; k++)c[i][j]+=(*this)[i][k]*b[k][j];","		a.swap(c);","		return (*this);","	}","	Matrix operator+(const Matrix &b) const{return (Matrix(*this)+=b);}","	Matrix operator-(const Matrix &b) const{return (Matrix(*this)-=b);}","	Matrix operator*(const Matrix &b) const{return (Matrix(*this)*=b);}","","	Matrix pow(lli k) const{","		Matrix ap(a), ret=I(height());","		while(k){","			if(k&1) ret*=ap;","			ap*=ap;","			k>>=1;","		}","		return ret;","	}","","	static pair<Matrix, Matrix> Gauss_Jordan(const Matrix &a, const Matrix &b){","		size_t n=a.height(), m=a.width(), l=b.width();","		Matrix c(n, m+l);","		for(int i=0; i<n; i++) for(int j=0; j<m; j++) c[i][j]=a[i][j];","		for(int i=0; i<n; i++) for(int j=0; j<l; j++) c[i][j+m]=b[i][j];","		int d=0;","		for(int i=0; i<m; i++){","			int p=-1;","			for(int j=d; j<n; j++)if(c[j][i]!=0){p=j; break;}","			if(p==-1) continue;","			swap(c[p], c[d]);","			T invc=T(1)/c[d][i];","			for(int j=i; j<m+l; j++) c[d][j]*=invc;","			for(int j=0; j<n; j++){","				if(j==d) continue;","				T c0=c[j][i];","				for(int k=i; k<m+l; k++)c[j][k]-=c0*c[d][k];","			}","			d++;","		}","		Matrix reta(n, m), retb(n, l);","		for(int i=0; i<n; i++) for(int j=0; j<m; j++) reta[i][j]=c[i][j];","		for(int i=0; i<n; i++) for(int j=0; j<l; j++) retb[i][j]=c[i][j+m];","		return make_pair(reta, retb);","	}","","	static pair<vector<T>, vector<vector<T>>> linear_equations(const Matrix &a, const vector<T> &b){","		int n=a.height(), m=a.width();","		Matrix B(n, 1);","		for(int i=0; i<n; i++) B[i][0]=b[i];","		auto p=Gauss_Jordan(a, B);","		vector<int> myon(n,-1);","		vector<int> nuo(m, -1);","		for(int i=0; i<n; i++){","			bool allzero=1;","			for(int j=0; j<m; j++)if(p.first[i][j]!=0){","					allzero=0;","					myon[i]=j;","					nuo[j]=i;","					break;","				}","			if(allzero && p.second[i][0]!=0){","				vector<T> retc;","				vector<vector<T>> retd;","				return make_pair(retc, retd);","			}","		}","		vector<T> c(m);","		vector<vector<T>> d;","		for(int i=0; i<m; i++){","			if(nuo[i]==-1){","				vector<T> v(m);","				v[i]=1;","				for(int j=0; j<n; j++)if(myon[j]!=-1) v[myon[j]]=-p.first[j][i];","				d.push_back(v);","			}else c[i]=p.second[nuo[i]][0];","		}","		return make_pair(c, d);","	}","","	Matrix inv() const{","		int n=height();","		Matrix b=I(n);","		auto p=Gauss_Jordan(*this, b);","		if(p.first[n-1][n-1]==0){","			Matrix ret(0);","			return ret;","		}","		return p.second;","	}","","	int rank() const{","		int n=height(), m=width();","		Matrix b(n, 0);","		auto p=Gauss_Jordan(*this, b);","		for(int i=0; i<n; i++){","			bool allzero=1;","			for(int j=0; j<m; j++)if(p.first[i][j]!=0){","					allzero=0;","					break;","				}","			if(allzero) return i;","		}","		return n;","	}","","	T det() const{","		size_t n=height();","		Matrix A(a);","		T ret(1);","		for(int i=0; i<n; i++){","			int p=-1;","			for(int j=i; j<n; j++)if(A[j][i]!=0){","					p=j; break;","				}","			if(p==-1)return 0;","			if(p!=i) ret*=(-1);","			swap(A[p], A[i]);","			ret*=A[i][i];","			T inva=T(1)/A[i][i];","			for(int j=i+1; j<n; j++){","				T a0=A[j][i];","				for(int k=i; k<n; k++)A[j][k]-=inva*a0*A[i][k];","			}","		}","		return ret;","	}","};",]
},
"NumberTheory.cpp": {
	"prefix": "NumberTheory.cpp" ,
	"body": ["struct number_theory{","	int SZ;","	vector<int> lpf, prime, mu, phi; // least prime factor, primes, mobius function, totient function, number of multiples","	number_theory(int SZ): SZ(SZ), lpf(SZ + 1), mu(SZ + 1, 1), phi(SZ + 1, 1){ // O(SZ)","		lpf[0] = lpf[1] = numeric_limits<int>::max() / 2;","		for(int i = 2; i <= SZ; ++ i){","			if(!lpf[i]) lpf[i] = i, prime.push_back(i);","			if(i / lpf[i] % lpf[i]) mu[i] = -mu[i / lpf[i]], phi[i] = phi[i / lpf[i]] * (lpf[i] - 1);","			else mu[i] = 0, phi[i] = phi[i / lpf[i]] * lpf[i];","			for(int j = 0; j < (int)prime.size() && prime[j] <= lpf[i] && prime[j] * i <= SZ; ++ j) lpf[prime[j] * i] = prime[j];","		}","	}","	int mu_large(long long x){ // O(sqrt(x))","		int res = 1;","		for(long long i = 2; i * i <= x; ++ i) if(x % i == 0){","			if(x / i % i) return 0;","			x /= i, res = -res;","		}","		if(x > 1) res = -res;","		return res;","	}","	long long phi_large(long long x){ // O(sqrt(x))","		long long res = x;","		for(long long i = 2; i * i <= x; ++ i) if(x % i == 0){","			while(x % i == 0) x /= i;","			res -= res / i;","		}","		if(x > 1) res -= res / x;","		return res;","	}","	template<class T> // O(n log n)","	vector<T> convolute(const vector<T> &a, const vector<T> &b){","		int n = (int)a.size();","		assert(n == (int)b.size());","		vector<T> res(n);","		for(int x = 1; x < n; ++ x) for(int y = 1; x * y < n; ++ y) res[x * y] += a[x] * b[y];","		return res;","	}","	template<class T> // O(n log n log k)","	vector<T> conv_exp(const vector<T> &a, long long e){","		int n = (int)a.size();","		vector<T> res(n), p(a.begin(), a.end());","		res[1] = 1;","		for(; e; e >>= 1, p = convolute(a, a)) if(e & 1) res = convolute(res, p);","		return res;","	}","	template<class T> // O(n log n)","	vector<T> mobius_transform(const vector<T> &a){","		int n = (int)a.size();","		vector<T> res(n);","		for(int x = 1; x < n; ++ x) for(int mx = x; mx < n; mx += x) res[mx] += a[x];","		return res;","	}","	template<class T> // O(n log n)","	vector<T> inverse_transform(const vector<T> &a){","		int n = (int)a.size();","		vector<T> res(n);","		for(int x = 1; x < n; ++ x) for(int y = 1; x * y < n; ++ y) res[x * y] += a[x] * mu[y];","		return res;","	}","	vector<int> mul_cnt;","	bool mul_cnt_ready = false;","	template<class T> // O(SZ log SZ)","	void init_mul_cnt(const vector<int> &a){","		mul_cnt_ready = true;","		vector<int> cnt(SZ + 1);","		mul_cnt.assign(SZ + 1, 0);","		for(auto x: a) ++ cnt[x];","		for(int x = 1; x <= SZ; ++ x) for(int mx = x; mx <= SZ; mx += x) mul_cnt[x] += cnt[mx];","	}","	template<class T> // Requires Z_p, O((SZ / g) log k)","	T count_tuples_with_gcd(int k, int g = 1){","		assert(mul_cnt_ready);","		T res = 0;","		for(int x = SZ / g; x >= 1; -- x) res += mu[x] * (T(mul_cnt[x * g]) ^ k);","		return res;","	}","};",]
},
"DC.cpp": {
	"prefix": "DC.cpp" ,
	"body": ["lli res =0;","vc<ii> f,g;","void dc(int l, int r, int L, int R){","	if(l>r)return;","	int mid = (l+r)/2;","	int pos = R;","	lli tmp = -inf<lli>;","	auto cost = [&](int i){","		return 1ll * (g[i].s+f[mid].s) * (g[i].f-f[mid].f);","	};","	fore(i,L,R+1){","		if(tmp < cost(i)){","			tmp = cost(i); // modificar esto.","			pos = i;","		}","	}","	res=max(res,tmp);","	dc(l,mid-1,L,pos);","	dc(mid+1,r,pos,R);","}",]
},
"CHT.cpp": {
	"prefix": "CHT.cpp" ,
	"body": ["struct Line {","    mutable lli k, m, p;","    bool operator<(const Line &o) const { return k < o.k; }","    bool operator<(double x) const { return p < x; }","};","","struct LineContainer: multiset<Line,less<>>{","	lli div(lli a, lli b){return a/b -((a^b)<0 and a%b);}","","	bool isect(iterator x, iterator y){","		if(y==end()){x->p=INF;return false;}","		if(x->k==y->k)x->p=x->m>y->m?INF:-INF;","		else x->p = div(y->m-x->m,x->k-y->k);","		return x->p>=y->p;","	}","","	void add(lli k, lli m){","		auto z = insert({k,m,0}),y=z++,x=y;","		while(isect(y,z))z=erase(z);","		if(x!=begin() and isect(--x,y))isect(x,y=erase(y));","		while((y=x)!=begin() and (--x)->p>=y->p)isect(x,erase(y));","	}","","	lli query(lli x){","		assert(!empty());","		auto l =*lower_bound(x);","		return l.k*x+l.m;","	 }","};",]
},
"SCC.cpp": {
	"prefix": "SCC.cpp" ,
	"body": ["struct StronglyConnectedComponents {","	int n, group_num, now_ord;","	vector<vector<int>> g;","	vector<int> low, ord, idx;","	StronglyConnectedComponents(int _n) :n(_n), low(n), ord(n, -1), idx(n), g(n), group_num(0), now_ord(0) {}","	void add_edge(int from, int to) {","		g[from].emplace_back(to);","	}","	void dfs(int cur, vector<int> &visited) {","		ord[cur] = low[cur] = now_ord++;","		visited.emplace_back(cur);","		for (auto nxt : g[cur]) {","			if (ord[nxt] == -1) {","				dfs(nxt, visited);","				low[cur]=min(low[cur], low[nxt]);","			}","			else {","				low[cur]=min(low[cur], ord[nxt]);","			}","		}","		if (ord[cur] == low[cur]) {","			while (true) {","				int v = visited.back();","				visited.pop_back();","				ord[v] = n; //別のdfs木からこないように","				idx[v] = group_num;","				if (cur == v) break;","			}","			group_num++;","		}","	}","","	//sccのidxに入ってる頂点番号 idxはトポロジカル順","	vector<vector<int>> build() {","		vector<int> visited;","		for (int i = 0; i < n; i++) if (ord[i] == -1) dfs(i, visited);","		for (int i = 0; i < n; i++) idx[i] = group_num - 1 - idx[i];","		vector<vector<int>> groups(group_num);","		for (int i = 0; i < n; i++) {","			groups[idx[i]].emplace_back(i);","		}","		return groups;","	}","};",]
},
"LCA.cpp": {
	"prefix": "LCA.cpp" ,
	"body": ["struct LowestCommonAncestor{","    int n,h;","    vector<vector<int>> G,par;","    vector<int> dep;","    LowestCommonAncestor(int n):n(n),G(n),dep(n){","        h=1;","        while((1<<h)<=n) ++h;","        par.assign(h,vector<int>(n,-1));","    }","    void add_edge(int u,int v){","        G[u].emplace_back(v);","        G[v].emplace_back(u);","    }","    void dfs(int v,int p,int d){","        par[0][v]=p;","        dep[v]=d;","        for (int u:G[v]){","            if (u!=p) dfs(u,v,d+1);","        }","    }","    void build(int r=0){","        dfs(r,-1,0);","        for (int k=0;k<h-1;++k){","            for (int v=0;v<n;++v){","                if (par[k][v]>=0){","                    par[k+1][v]=par[k][par[k][v]];","                }","            }","        }","    }","    int lca(int u,int v){","        if (dep[u]>dep[v]) swap(u,v);","        for (int k=0;k<h;++k){","            if ((dep[v]-dep[u])&1<<k){","                v=par[k][v];","            }","        }","        if (u==v) return u;","        for (int k=h-1;k>=0;--k){","            if (par[k][u]!=par[k][v]){","                u=par[k][u]; v=par[k][v];","            }","        }","        return par[0][u];","    }","    int distance(int u,int v){","        return dep[u]+dep[v]-dep[lca(u,v)]*2;","    }","};",]
},
"BiComp.cpp": {
	"prefix": "BiComp.cpp" ,
	"body": ["struct Biconnected{","	// articulation point iff B[i] !=0","	// nbc = number of biconnected components","	struct edge {int u,v,comp;bool bridge;};","	vector<edge> e;","	vector<vector<int>>g;","	int n,nbc,T;","	void add_edge(int u, int v){","		g[u].pb(sz(e));","		g[v].pb(sz(e));","		e.pb({u,v,-1,0});","	}","	vector<int>D,B,art;","	stack<int> st;","	void dfs(int u,int pe){","		B[u]=D[u]=T++;","		for(int ne:g[u])if(ne!=pe){","			int v=e[ne].u^e[ne].v^u;","			if(D[v]<0){","				st.push(ne);","				dfs(v,ne);","				if(B[v]>D[u])e[ne].bridge = true;","				if(B[v]>=D[u]){","					while(1){","						int last=st.top();st.pop();","						e[last].comp=nbc;","						if(last==ne)break;","					}","					nbc++; art[u]++;","				}","				B[u]=min(B[u],B[v]);","			}","			else if(D[v]<D[u])st.push(ne),B[u]=min(B[u],D[v]);","		}","	}","","	Biconnected(int n):n(n),nbc(0),T(0){","		D = vector<int>(n,-1);","		art = B = vector<int>(n,0);","		g = vector<int>(n);","	}","","	void run(){","		fore(i,0,n)if(D[i]<0)dfs(i,-1),art[i]--;","	}","","	auto get_cmp(){","		vector<vector<int>>v(nbc);","		for(auto i:e)v[i.comp].pb(i.u), v[i.comp].pb(i.v);","		return v;","	}","","};",]
},
"MST.cpp": {
	"prefix": "MST.cpp" ,
	"body": ["pair<int, int> f(int i) { return {(i) / 2, (i) % 2}; }","","struct UF {","  vector<int> p;","","  UF(int N) { p = vector<int>(N, -1); }","","  int root(int a) {","    if(p[a] < 0) return a;","    return p[a] = root(p[a]);","  }","","  lli size(int a) { return -p[root(a)]; }","","  bool connect(int a, int b) {","    a = root(a);","    b = root(b);","    if(a == b) return false;","    if(size(a) < size(b)) swap(a, b);","","    p[a] += p[b];","    p[b] = a;","","    return true;","  }","","  bool same(int a, int b) { return root(a) == root(b); }","};","","struct mst {","  struct edge {","    int from, to, used;","    lli cost;","","    edge(int x, int y, lli z) : from(x), to(y), cost(z) {}","","    bool operator<(const edge& e) const { return cost < e.cost; }","  };","","  int V;","  vector<int> p;","  vector<edge> es;","","  mst(int _V) : V(_V), p(_V) {","    for(auto& i : p) i = -1;","  }","","  void add(int u, int v, lli c) { es.emplace_back(u, v, c); }","","  int root(int a) {","    if(p[a] < 0) return a;","    return p[a] = root(p[a]);","  }","","  int size(int a) { return -p[root(a)]; }","","  bool connect(int a, int b) {","    a = root(a);","    b = root(b);","    if(a == b) return false;","    if(size(a) < size(b)) swap(a, b);","","    p[a] += p[b];","    p[b] = a;","","    return true;","  }","","  bool same(int a, int b) { return root(a) == root(b); }","","  vector<edge> build() {","    sort(es.begin(), es.end());","","    vector<edge> res;","","    fore(i, 0, (lli)es.size()) {","      edge e = es[i];","      if(!same(e.from, e.to)) {","        connect(e.from, e.to);","        res.push_back(e);","      }","    }","    return res;","  }","};",]
},
"DominatorTree.cpp": {
	"prefix": "DominatorTree.cpp" ,
	"body": ["struct DominatorTree{","	int n;","	vector<vector<int>>G,rG;","	vector<int>semi,id,rid,par,mn,anc;","	DominatorTree(int n): n(n),G(n),rG(n),semi(n),id(n,-1),rid(n),par(n,-1),mn(n),anc(n){","    for(int i=0;i<n;i++)semi[i]=mn[i]=anc[i]=i;","	}","	void addEdge(int a,int b){","		G[a].push_back(b);rG[b].push_back(a);","	}","	int find(int v){","		if(anc[v]==v)return v;","		int a=find(anc[v]);","		if(id[semi[mn[anc[v]]]]<id[semi[mn[v]]])mn[v]=mn[anc[v]];","		return anc[v]=a;","	}","","	void link(int c,int p){","		anc[c]=p;","	}","","	void dfs(int v,int p,int &k){","		id[v]=k;","		rid[k++]=v;","		par[v]=p;","		for(int c:G[v])if(id[c]==-1)dfs(c,v,k);","	}","","	vector<int>calc(int root){","		int sz=0;","		dfs(root,-1,sz);","    vector<int>us(n);","    vector<vector<int>>bucket(n);","		for(int i=sz-1;i>0;i--){","			int w=rid[i];","			for(int v:rG[w])if(id[v]!=-1){","				find(v);","				if(id[semi[mn[v]]]<id[semi[w]])semi[w]=semi[mn[v]];","			}","			bucket[semi[w]].pb(w);","			for(int v:bucket[par[w]]){","				find(v);","				us[v]=mn[v];","			}","			bucket[par[w]].clear();","			link(w,par[w]);","		}","    vector<int>idom(n,-1);","		for(int i=1;i<sz;i++){","			int w=rid[i];","			if(semi[w]==semi[us[w]])idom[w]=semi[w];","			else idom[w]=idom[us[w]];","		}","		return idom;","	}","};",]
},
"TwoEdgeConn.cpp": {
	"prefix": "TwoEdgeConn.cpp" ,
	"body": ["struct two_edge_connectivity{","	vector<int>order,cmp;","	stack<int> s,roots;","	vector<bool> ins;","	vector<vector<int>>each_bcc;","	vector<pair<int,int>>brige;","	two_edge_connectivity(auto g){","		int n=g.size();","		order.resize(n,0);","		ins.resize(n,0);","		cmp.resize(n);","		for(int i=0;i<n;i++){","			if(!order[i])dfs(g,i,-1);","		}","	}","	void dfs(const auto& g,int v,int p){","		order[v]=(p==-1?0:order[p])+1;","		s.emplace(v);","		ins[v]=1;","		roots.emplace(v);","		bool f=1;","		for(auto e:g[v]){","			if(e==p&&f){f=0;continue;}","			if(!order[e])dfs(g,e,v);","			else if(e!=v&&ins[e])while(order[roots.top()]>order[e])roots.pop();","		}","		if(v==roots.top()){","			if(p!=-1)brige.push_back(minmax(p,v));","			vector<int>bcc;","			while(1){","				int e=s.top();s.pop();ins[e]=0;","				bcc.push_back(e);","				cmp[v]=each_bcc.size();","				if(e==v)break;","			}","			each_bcc.push_back(bcc);","			roots.pop();","		}","	}","	auto get_bcc(){return each_bcc;}","	auto get_v(){return cmp;}","	auto get_brige(){return brige;}","};",]
},
"2-sat.cpp": {
	"prefix": "2-sat.cpp" ,
	"body": ["","struct StronglyConnectedComponents {","  int V;","  std::vector<std::vector<int>> G, rG;","  std::vector<int> vs, cmp;","  std::vector<bool> used;","","  StronglyConnectedComponents(const int V)","      : V(V), G(V), rG(V), cmp(V), used(V) {}","","  void add_edge(const int from, const int to) {","    G[from].push_back(to);","    rG[to].push_back(from);","  }","","  void dfs(const int v) {","    used[v] = true;","    for (int c : G[v])","      if (not used[c]) dfs(c);","    vs.push_back(v);","  }","","  void rdfs(const int v, const int k) {","    used[v] = true;","    cmp[v] = k;","    for (int c : rG[v])","      if (not used[c]) rdfs(c, k);","  }","","  int run() {","    std::fill(used.begin(), used.end(), false);","    vs.clear();","    for (int v = 0; v < V; v++)","      if (!used[v]) dfs(v);","    std::fill(used.begin(), used.end(), false);","    int k = 0;","    for (int i = vs.size() - 1; i >= 0; i--)","      if (!used[vs[i]]) rdfs(vs[i], k++);","    return k;","  }","","  std::vector<int> create_order() {","    std::vector<int> order(V);","    for (std::size_t i = 0; i < cmp.size(); i++) {","      order[cmp[i]] = i;","    }","    return order;","  }","};","","struct TwoSat : StronglyConnectedComponents {","  int N;","  std::vector<bool> ans;","  TwoSat(const int N) : StronglyConnectedComponents(2 * N + 1), N(N), ans(N) {}","","  void add_constraint(int a, int b) {","    add_edge(neg(a), pos(b));","    add_edge(neg(b), pos(a));","  }","  int pos(const int v) { return v > 0 ? v : N - v; }","  int neg(const int v) { return v > 0 ? N + v : -v; }","","  bool run() {","    StronglyConnectedComponents::run();","    for (int i = 1; i <= N; i++) {","      if (cmp[i] == cmp[i + N]) {","        return false;","      }","    }","","    for (int i = 1; i <= N; i++) {","      ans[i - 1] = cmp[i] > cmp[i + N];","    }","    return true;","  }","};",]
},
"Hungarian.cpp": {
	"prefix": "Hungarian.cpp" ,
	"body": ["typedef long double td;","typedef vector<int> vi;","typedef vector<td> vd;","const td INF=1e10;//for maximum set INF to 0, and negate costs","bool zero(td x){return fabs(x)<1e-9;}//change to x==0, for ints/ll","struct Hungarian{","    int n; vector<vd> cs; vi L, R;","    Hungarian(int N, int M):n(max(N,M)),cs(n,vd(n)),L(n),R(n){","        fore(x,0,N)fore(y,0,M)cs[x][y]=INF;","    }","    void set(int x,int y,td c){cs[x][y]=c;}","	td assign() {","		int mat = 0; vd ds(n), u(n), v(n); vi dad(n), sn(n);","		fore(i,0,n)u[i]=*min_element(all(cs[i]));","		fore(j,0,n){","            v[j]=cs[0][j]-u[0];","            fore(i,1,n)v[j]=min(v[j],cs[i][j]-u[i]);","        }","		L=R=vector<int>(n, -1);","		fore(i,0,n)fore(j,0,n)","			if(R[j]==-1&&zero(cs[i][j]-u[i]-v[j])){","                L[i]=j;R[j]=i;","                mat++;","                break;","            }","		for(;mat<n;mat++){","		    int s=0, j=0, i;","		    while(L[s] != -1)s++;","		    fill(all(dad),-1);","            fill(all(sn),0);","		    fore(k,0,n)ds[k]=cs[s][k]-u[s]-v[k];","		    for(;;){","		        j = -1;","		        fore(k,0,n)if(!sn[k]&&(j==-1||ds[k]<ds[j]))j=k;","		        sn[j] = 1; i = R[j];","		        if(i == -1) break;","		        fore(k,0,n)if(!sn[k]){","		            auto new_ds=ds[j]+cs[i][k]-u[i]-v[k];","		            if(ds[k] > new_ds){ds[k]=new_ds;dad[k]=j;}","		        }","		    }","		    fore(k,0,n)if(k!=j&&sn[k]){","                auto w=ds[k]-ds[j];","                v[k]+=w,u[R[k]]-=w;","            }","		    u[s] += ds[j];","		    while(dad[j]>=0){","                int d = dad[j];","                R[j]=R[d];","                L[R[j]]=j;j=d;","            }","		    R[j]=s;L[s]=j;","		}","		td value=0;","        fore(i,0,n)value+=cs[i][L[i]];","		return value;","	}","};",]
},
"MCMF.cpp": {
	"prefix": "MCMF.cpp" ,
	"body": ["template <typename tf, typename tc>struct MCMF{","	int n;","	tf INFFLOW;","	tc INFCOST;","	vector<tc> prio, pot;","	vector<tf> curflow;","	vector<int> prevedge,prevnode;","	priority_queue<pair<tc, int>, vector<pair<tc, int>>, greater<pair<tc, int>>> q;","	struct edge{int to, rev; tf f, cap; tc cost;};","	vector<vector<edge>> g;","	MCMF(int n):n(n),prio(n),curflow(n),prevedge(n),prevnode(n),pot(n),g(n){","    INFFLOW=numeric_limits<tf>::max() / 2;","    INFCOST=numeric_limits<tc>::max() / 2;","  }","	void add(int s, int t, tf cap, tc cost) {","		g[s].pb((edge){t,sz(g[t]),0,cap,cost});","		g[t].pb((edge){s,sz(g[s])-1,0,0,-cost});","	}","	pair<tf,tc> get_flow(int s, int t) {","		tf flow=0; tc flowcost=0;","		while(1){","			q.push({0, s});","			fill(all(prio),INFCOST);","			prio[s]=0; curflow[s]=INFFLOW;","			while(!q.empty()) {","				auto cur=q.top();","				tc d=cur.f;","				int u=cur.s;","				q.pop();","				if(d!=prio[u]) continue;","				for(int i=0; i<sz(g[u]); ++i) {","					edge &e=g[u][i];","					int v=e.to;","					if(e.cap<=e.f) continue;","					tc nprio=prio[u]+e.cost+pot[u]-pot[v];","					if(prio[v]>nprio) {","						prio[v]=nprio;","						q.push({nprio, v});","						prevnode[v]=u; prevedge[v]=i;","						curflow[v]=min(curflow[u], e.cap-e.f);","					}","				}","			}","			if(prio[t]==INFCOST) break;","			fore(i,0,n) pot[i]+=prio[i];","			tf df=min(curflow[t], INFFLOW-flow);","			flow+=df;","			for(int v=t; v!=s; v=prevnode[v]) {","				edge &e=g[prevnode[v]][prevedge[v]];","				e.f+=df; g[v][e.rev].f-=df;","				flowcost+=df*e.cost;","			}","		}","		return {flow,flowcost};","	}","};",]
},
"BiMatching.cpp": {
	"prefix": "BiMatching.cpp" ,
	"body": ["struct Bipartite_Matching {","  vector<vector<int>> graph;","  vector<int> dist, match, used;","  vector<bool> vv;","","  Bipartite_Matching(int n, int m) {","    graph.resize(n);","    match.assign(m, -1);","    used.assign(n, -1);","  }","","  void add(int u, int v) { graph[u].push_back(v);}","","  void bfs() {","    dist.assign(graph.size(), -1);","    queue< int > que;","    for(int i = 0; i < graph.size(); i++) {","      if(used[i] == -1) {","        que.emplace(i);","        dist[i] = 0;","      }","    }","","    while(!que.empty()) {","      int a = que.front();","      que.pop();","      for(auto &b : graph[a]) {","        int c = match[b];","        if(c >= 0 && dist[c] == -1) {","          dist[c] = dist[a] + 1;","          que.emplace(c);","        }","      }","    }","  }","","  bool dfs(int a) {","    vv[a] = true;","    for(auto &b : graph[a]) {","      int c = match[b];","      if(c < 0 || (!vv[c] && dist[c] == dist[a] + 1 && dfs(c))) {","        match[b] = a;","        used[a] = b;","        return (true);","      }","    }","    return (false);","  }","","  int bipartite_matching() {","    int ret = 0;","    while(true) {","      bfs();","      vv.assign(graph.size(), false);","      int flow = 0;","      for(int i = 0; i < graph.size(); i++) {","        if(used[i] == -1 && dfs(i)) ++flow;","      }","      if(flow == 0) return (ret);","      ret += flow;","    }","  }","};",]
},
"Dinic.cpp": {
	"prefix": "Dinic.cpp" ,
	"body": ["template <typename flow_t> struct Dinic {","    const flow_t INF;","","    struct edge {","        int to;","        flow_t cap;","        int rev;","        bool isrev;","        int idx;","    };","","    vector<vector<edge>> graph;","    vector<int> min_cost, iter;","","    Dinic(int V) : INF(numeric_limits<flow_t>::max()), graph(V) {}","","    void add(int from, int to, flow_t cap, int idx = -1) {","        graph[from].emplace_back((edge){to, cap, (int)graph[to].size(), false, idx});","        graph[to].emplace_back((edge){from, 0, (int)graph[from].size() - 1, true, idx});","    }","","    bool bfs(int s, int t) {","        min_cost.assign(graph.size(), -1);","        queue<int> que;","        min_cost[s] = 0;","        que.push(s);","        while(!que.empty() && min_cost[t] == -1) {","            int p = que.front();","            que.pop();","            for(auto &e : graph[p]) {","                if(e.cap > 0 && min_cost[e.to] == -1) {","                    min_cost[e.to] = min_cost[p] + 1;","                    que.push(e.to);","                }","            }","        }","        return min_cost[t] != -1;","    }","","    flow_t dfs(int idx, const int t, flow_t flow) {","        if(idx == t) return flow;","        for(int &i = iter[idx]; i < graph[idx].size(); i++) {","            edge &e = graph[idx][i];","            if(e.cap > 0 && min_cost[idx] < min_cost[e.to]) {","                flow_t d = dfs(e.to, t, min(flow, e.cap));","                if(d > 0) {","                    e.cap -= d;","                    graph[e.to][e.rev].cap += d;","                    return d;","                }","            }","        }","        return 0;","    }","","    flow_t max_flow(int s, int t) {","        flow_t flow = 0;","        while(bfs(s, t)) {","            iter.assign(graph.size(), 0);","            flow_t f = 0;","            while((f = dfs(s, t, INF)) > 0) flow += f;","        }","        return flow;","    }","","    void output() {","        for(int i = 0; i < graph.size(); i++) {","            for(auto &e : graph[i]) {","                if(e.isrev) continue;","                auto &rev_e = graph[e.to][e.rev];","                cout << i << \"->\" << e.to << \" (flow: \" << rev_e.cap << \"/\" << e.cap + rev_e.cap << \")\" << ENDL;","            }","        }","    }","};",]
},
}
